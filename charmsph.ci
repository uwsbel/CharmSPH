mainmodule charmsph {
  include "pup_stl.h";
  include "ckio.h";

  /* Charm++ Globals */
  readonly CProxy_Main mainProxy;       //central controller
  readonly CProxy_Cell cellArray;     //array that houses atoms
  readonly CProxy_Compute computeArray; //computational kernels
  readonly CkGroupID mCastGrpID;      //multicast group handle
  
  /* SPH  Globals */
  readonly int3 cellArrayDim;   // Y dimension of the Cell array
  readonly vec3 domainMin;
  readonly vec3 domainMax;
  readonly vec3 domainDim;
  readonly vec3 fluidMin;
  readonly vec3 fluidMax;
  readonly vec3 cellSize;
  readonly vec3 mDist;

  /* Charm++ RTS Globals */
  readonly int finalStepCount;		// number of steps in the simulaion
  readonly int firstLdbStep;		// begin load balancing after this many steps
  readonly int ldbPeriod;		// load balancing period
  readonly int checkptFreq;     // do FT every period
  readonly int checkptStrategy; // choose the checkpoint strategy
  readonly std::string logs;   // log file for checkpointing
  readonly vec3 gravity; 
  
  /* Charm++ I/O Globals */
  readonly int numChares;
  readonly int numLinesPerChare; 
  readonly int lineLength;


  //central controller chare
  mainchare [migratable] Main 
  { 
    entry Main(CkArgMsg* msg);
    entry [reductiontarget] void energySum(double iE, double fE);  //reduction of potential energy
    // called when computes have been created
    entry [reductiontarget] void run() 
    {
      serial 
      {
        computeArray.doneInserting();
        CkPrintf("Computes: %d .... created\n", (NUM_NEIGHBORS/2+1)*cellArrayDim.x * cellArrayDim.y * cellArrayDim.z);
        CkPrintf("Computes numLocalElements: %d ....\n", computeArray.numLocalElements());
        CkPrintf("Starting simulation .... \n\n");
        CkPrintf("Simulation Parameters: \n");
        CkPrintf("Gravity: ");
        gravity.print();
        cellArray.run();
        computeArray.run();
        startBenchmarkTime = CkWallTimer();
      }     

      //receive intial and final energies and compare
      when energySum(double iE1, double fE1) when energySum(double iE2, double fE2) serial {
        if(fabs(fE1 + fE2 - iE1 - iE2) > ENERGY_VAR) {
          CkPrintf("Energy value has varied significantly from %E to %E\n", iE1 + iE2, fE1 + fE2);
          CkPrintf("\nEnergy conservation test failed for maximum allowed variation of %E units.\nSIMULATION UNSUCCESSFULL\n",ENERGY_VAR);  
        } else {
          CkPrintf("\nEnergy conservation test passed for maximum allowed variation of %E units.\nSIMULATION SUCCESSFULL \n",ENERGY_VAR);
        }
        CkPrintf("Total application time %f s\n", (CkWallTimer() - startBenchmarkTime));
        CkExit();
      }
    };

    entry void ready(Ck::IO::FileReadyMsg *m);
    entry void startWrite(Ck::IO::SessionReadyMsg *m);
    entry void stepWritten(CkReductionMsg *m);
    entry void closed(CkReductionMsg *m);

    // entry void ready();
    // entry void startWrite();
    // entry void stepWritten();
    // entry void closed();

    entry void writeStep(int step, int iter)
    {
      serial {
        CkPrintf("Writing step %d\n", step);
        Ck::IO::Options opts;
        /* How much contiguous data (in bytes) should be assigned to each active PE*/
        opts.peStripe = 200; // Amount of contiguous data
        /* How much contiguous data (in bytes) should a PE gather before writing it out */
        opts.writeStripe = 1;
        /* The Callback is a generic way to call an entry method once some library call is done */
        CkCallback opened(CkIndex_Main::ready(NULL), thisProxy);
        opened.setRefnum(0);
        char name[20];
        sprintf(name, "output2/step.%d.csv", step);

        //cellArray.writeCellChare(step);
        // opened.send(NULL);
        /* Once open is done the opened callback will call CkIndex_Main::ready */
        Ck::IO::open(name, opened, opts);
      }

      //when ready() serial {
      when ready(Ck::IO::FileReadyMsg *m) serial {
        stepFiles.at(0) = m->file;
        CkCallback sessionStart(CkIndex_Main::startWrite(0), thisProxy);
        sessionStart.setRefnum(1); // refNum is just used to check at what point we are at
        CkCallback sessionEnd(CkIndex_Main::stepWritten(0), thisProxy);
        sessionEnd.setRefnum(2);

        int fileSize = numChares * numLinesPerChare * lineLength;
        int offset = 0;
        // std::string h = "hello\n"; 
        // The following line commits one last line to the file. In this case hello.
        // // Ck::IO::startSession(f.at(iter/4), 10*n, 0, sessionStart,
        //                      h.c_str(), h.size(), 10*n,
        //                      sessionEnd);
        Ck::IO::startSession(stepFiles.at(0), fileSize, offset, sessionStart, sessionEnd);
      

        CkPrintf("Main saw file ready the number of chares is %d\n", stepFiles.size());
        delete m;
      }

      //when startWrite() serial {
      when startWrite(Ck::IO::SessionReadyMsg *m) serial {
        // testers = CProxy_test::ckNew(m->session, n);
        cellArray.writeCellChare(m->session, step);
        CkPrintf("Main saw session ready\n");
        delete m;
      }
      
      // when stepWritten() serial {
      when stepWritten(CkReductionMsg *m) serial {
        //delete m;
        CkPrintf("Main saw write done\n");
        // Read file and validate contents
        CkCallback cb(CkIndex_Main::closed(0), thisProxy);
        cb.setRefnum(3);
        Ck::IO::close(stepFiles.at(0), cb);
        delete m;
      }

      // when closed() serial {
      when closed(CkReductionMsg *m) serial {
        CkPrintf("Main saw close done\n");
        delete m;
      }
    };


  };

  //message used to send particles to computes
  message ParticleDataMsg{
    Particle part[];
  };

  //chares to house atoms
  array [3D] Cell {
    entry Cell();  
    entry void createComputes();    //call to insert computes that I need  
    entry void receiveParticles(const std::vector<Particle> &updates);   //receive atoms that have migrated to neighboring cells to me
    entry void ResumeFromSync();    //resume from here after load balancing
    entry [reductiontarget] void startCheckpoint(); //reduction to start checkpointing
    entry void recvCheckPointDone();  //checkpointing done, resume application
    //entry [reductiontarget] void reduceForces(vec3 forces[n], int n);   //receives forces from my computes on my atoms
    entry [reductiontarget] void reduceForcesSPH(vec4 dVel_dRho[n], int n);   //receives forces from my computes on my atoms
    //entry void writeCellChare(Ck::IO::Session token);
    entry void writeCellChare(Ck::IO::Session token, int step);
    // entry void writeCellChare(int step);

    //function to perform iterations for Cells
    entry void run() 
    {
      if (thisIndex.x==0 && thisIndex.y==0 && thisIndex.z==0) serial 
      {
        stepTime = CkWallTimer();
        mainProxy.writeStep(0, 0);
      }

      serial 
      { 
        createSection(); 
        writeCell(0);
      }

      for(stepCount = 1; stepCount <= finalStepCount; stepCount++) 
      {
        //send current atom positions to my computes 
        serial 
        { 
          if((stepCount % 100) == 0 && (thisIndex.x == 0 && thisIndex.y == 0 && thisIndex.z == 0))
          {
            //writeCell(stepCount);
            mainProxy.writeStep(stepCount, 0);
          }
          //CkPrintf("1. First sendPositions\n"); 
          sendPositions(1); 
        } 

        //update properties of atoms using new force values 
        //when reduceForces(vec3 forces[n], int n) serial { updateProperties(forces); }
        when reduceForcesSPH(vec4 dVel_dRho[n], int n) serial 
        { 
          //CkPrintf("3, reduceForces was called. First update properties\n"); 
          updatePropertiesSPH(dVel_dRho, 1); 
        }

        serial 
        { 
          //CkPrintf("4. Second sendPositions\n"); 
          sendPositions(2); 
        } 

        //update properties of atoms using new force values 
        when reduceForcesSPH(vec4 dVel_dRho[n], int n) serial 
        { 
          //CkPrintf("6. reduceForces was called for the second time.\n"); 
          updatePropertiesSPH(dVel_dRho, 2); 
        }


        if ((stepCount %  MIGRATE_STEPCOUNT) == 0) 
        {
          //send atoms that have moved beyond my cell to neighbors
          serial 
          { 
            migrateParticles(stepCount); 
          } 
    
          //receive particles from my neighbors
          for(updateCount = 0; updateCount < inbrs; updateCount++) 
          {
            when receiveParticles(const std::vector<Particle> &updates) serial 
            {
              for (int i = 0; i < updates.size(); ++i)
              {
                particles.push_back(updates[i]); //add particles that have moved from neighboring cells to my cell
              } 
            }
          }
        }

        if (thisIndex.x == 0 && thisIndex.y == 0 && thisIndex.z == 0) serial {
          CkPrintf("Step %d Benchmark Time %lf ms/step\n", 
          stepCount, ((CkWallTimer() - stepTime))*1000);
          stepTime = CkWallTimer();
        }

        //periodically call load balancer
        if (stepCount >= firstLdbStep && (stepCount - firstLdbStep) % ldbPeriod == 0) 
        {
          serial 
          { 
            AtSync(); 
          }
          when ResumeFromSync() { }
        }

        //periodically checkpointing
        if (stepCount % checkptFreq == 0) 
        {
          serial 
          {
            //coordinate to start checkpointing
            if (thisIndex.x == 0 && thisIndex.y == 0 && thisIndex.z == 0)
            {
              CkPrintf("[%d] CHECKPOINT at step %d\n", CkMyPe(), stepCount);
            }
            contribute(CkCallback(CkReductionTarget(Cell,startCheckpoint),thisProxy(0,0,0)));
          }
          if (thisIndex.x == 0 && thisIndex.y == 0 && thisIndex.z == 0) {
            when startCheckpoint() serial 
            {
              CkCallback cb(CkIndex_Cell::recvCheckPointDone(),thisProxy);
              if (checkptStrategy == 0) 
              {
                CkStartCheckpoint(logs.c_str(), cb);
              }
              else CkStartMemCheckpoint(cb);
            }
          }
          when recvCheckPointDone() { }
        }

#if CMK_MEM_CHECKPOINT

        //kill one of processes to demonstrate fault tolerance
        if (stepCount == 60 && thisIndex.x == 1 && thisIndex.y == 1 && thisIndex.z == 0) serial {
          if (CkHasCheckpoints()) {
            CkPrintf("CkDieNow step 60\n");
            CkDieNow();
          }
        }
#endif
      }

      //everything done, reduction on kinetic energy
      serial { contribute(2*sizeof(double), energy,CkReduction::sum_double, CkCallback(CkReductionTarget(Main,energySum),mainProxy)); }
    };
  };

  //chares that do force computations for pair of cells
  array [6D] Compute {
    entry Compute();
    entry void ResumeFromSync();
    entry void calculateForces(ParticleDataMsg *msg);

    entry void run() {
      for (stepCount = 1; stepCount <= finalStepCount; stepCount++) 
      {
        //self interaction check
        if (thisIndex.x1==thisIndex.x2 && thisIndex.y1==thisIndex.y2 && thisIndex.z1==thisIndex.z2)
        {
          when calculateForces(ParticleDataMsg *msg) serial 
          { 
            //CkPrintf("2. First self interact...\n");
            selfInteractSPH(msg); 
          }
          when calculateForces(ParticleDataMsg *msg) serial 
          { 
            //CkPrintf("5. Second self interact...\n");
            selfInteractSPH(msg); 
          }
        }
        else
        {
          //receive positions from two cells
          when calculateForces(ParticleDataMsg *msg1) when calculateForces(ParticleDataMsg *msg2) serial 
          { 
            //CkPrintf("2. First interact");
            interactSPH(msg1, msg2); 
          }
          when calculateForces(ParticleDataMsg *msg1) when calculateForces(ParticleDataMsg *msg2) serial 
          { 
            //CkPrintf("5. second interact");

            interactSPH(msg1, msg2); 
          }
        }
        //periodically call load balancer
        if (stepCount >= firstLdbStep && (stepCount - firstLdbStep) % ldbPeriod== 0) {
          serial { AtSync();}
          when ResumeFromSync() { }
        }
      }
      //everything done, reduction on potential energy
      serial 
      { 
        contribute(2*sizeof(double),energy, CkReduction::sum_double, CkCallback(CkReductionTarget(Main,energySum),mainProxy)); 
      }
    };
  };
};
